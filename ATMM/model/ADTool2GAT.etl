pre {
  "Running ETL".println();
}

post {
  "Done".println();
}

rule ADTool2GAT 
	transform r : ADTool!t_node
	to f : AT!ATNode {
	
	guard : (r.parentNode.tagName.equals("adtree"))
	


	
	"Detected ADTree node".println();

	r.e_label.text.println();
	
	var children = r.c_node;
	
	f.Name = r.e_label.text;
	f.Type = r.findType();
	f.Role = AT!ATRole#Attack;

	if(children.size()>0){
 		for(c in children){
  		f.Children.add(c.handleChildren(true, f));
 		}
	}
	f.countChildren(r.c_node);
}

rule ADToolDomain2GATDomain
	transform ad : ADTool!t_domain
	to gad : AT!Domain {
	
	gad.ID = ad.a_id;
	gad.Class = ad.e_class.text;
	gad.Tool = ad.e_tool.text;
	
} 


operation Any countChildren(c : Collection) {
	c.size().println();
}

operation ADTool!t_node findType(){
	if(self.a_refinement.equals("disjunctive")){
		return (AT!ATType#OR);
	} else {
		return (AT!ATType#AND);
	}
	
}


operation ADTool!t_node handleChildren(b : Boolean, parent : AT!ATNode) : AT!ATNode{
var children = self.c_node;
var parameters = self.c_parameter;
var result = new AT!ATNode();

result.Name = self.e_label.text;
result.Type = self.findType();

result.Parents.add(parent);

// Reverse roles if node contains switchRole attribute
if(("yes").equals(self.a_switchRole)){
	b = not b;
}

if (b) {
	result.Role = AT!ATRole#Attack;
} else {
	result.Role =  AT!ATRole#Defense;
}
 
if(children.size()>0){
	for(c in children){
  		result.Children.add(c.handleChildren(b, result));
 	}
} else {
	for(p in parameters){
		var param = new AT!ATAttribute();
		param.Key = p.a_domainId;
		param.Value = p.text;
		param.DomainID = p.a_domainId;
		result.Attributes.add(param);
	}
}

return result;
}

